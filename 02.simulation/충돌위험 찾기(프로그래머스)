import java.util.*;
class Solution {
  
    List<Integer>[][] arr = new ArrayList[101][101];
    
    public int solution(int[][] points, int[][] routes) {
     
        // 동시 충돌을 2차원 배열에 만들기 int 값 두개 -> 이차원 배열 이용
        for (int i=0; i<=100; i++) {
            for (int j=0; j<=100; j++) {
                arr[i][j] = new ArrayList<>();
            }
        }
        int[][] dest = new int[routes.length][2];
        for (int i=0; i<routes.length; i++) {
            int second = 0;
            for (int j =0; j < routes[i].length-1; j++) {
                int start = routes[i][j]-1;
                int end = routes[i][j+1] -1;
               second = move( points[start][0],  points[start][1], points[end][0],  points[end][1], second); 
            }
        }
        
         int answer = 0;
        for (int i=0; i<=100; i++) {
            for (int j=0; j<=100; j++) {
                HashMap<Integer, Integer> map = new HashMap<>();
                for (int k=0; k<arr[i][j].size(); k++) {
                    int t = arr[i][j].get(k);
                    int cnt = map.getOrDefault(t, 0);
                    if(cnt == 1) {
            //            System.out.println("충돌 발생" +t + " 초 " + " x" + i + " j" + j );
                        answer++;
                    }
                    map.put(t, cnt + 1);
                }
            }
        }

        return answer;
    }
    
    public int move(int startX, int startY, int endX, int endY, int second ) {
        if(second == 0) {
                   arr[startX][startY].add(second++);  
        }

        while(true) {
            if(endX < startX) { 
                startX--; // 목적지가 더 작은 경우
            } else if (endX> startX){
                startX++; // 목적지가 더 큰 경우
            } else {
                // x 가 같은 경우
                if (endY > startY) {
                    startY++;
                } else if (endY < startY) {
                    startY--;
                } else {
                    break;
                }
            } 

            arr[startX][startY].add(second++);
        }
        return second;
    }
}
